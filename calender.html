<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シフト壁紙ジェネレーター</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 壁紙生成用にEmblema Oneフォントを読み込む -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Emblema+One&display=swap" rel="stylesheet">
    <style>
        /* サイトのUIはデフォルトフォントを使用 */
        body {
            font-family: sans-serif;
        }
        /* iPhone 15の画面アスペクト比（約19.5:9）を維持するためのスタイル */
        .canvas-container {
            width: 100%;
            max-width: 300px; /* プレビューの最大幅 */
            aspect-ratio: 1179 / 2556;
            margin: auto;
            border-radius: 1.5rem;
            overflow: hidden;
            position: relative;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        /* カレンダーの日付スタイル */
        .calendar-day {
            padding: 0.25rem;
            cursor: pointer;
            border-radius: 9999px; /* full circle */
            transition: background-color 0.2s, color 0.2s;
            line-height: 1.75rem;
            width: 1.75rem;
            height: 1.75rem;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: auto;
        }
        .calendar-day.selected {
            background-color: #4338ca; /* indigo-700 */
            color: white;
            font-weight: bold;
        }
        .calendar-day.disabled {
            color: #9ca3af; /* gray-400 */
            cursor: not-allowed;
        }
        /* 確認モーダルのスタイル */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">シフト壁紙ジェネレーター</h1>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- 入力フォームエリア -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">1. シフトの日付を選択</h2>
                
                <div id="calendar-ui">
                    <div id="calendar-header" class="flex justify-between items-center mb-4">
                        <button id="prev-month-btn" class="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300" aria-label="前の月へ">&lt;</button>
                        <h3 id="month-year-header" class="text-lg font-bold"></h3>
                        <button id="next-month-btn" class="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300" aria-label="次の月へ">&gt;</button>
                    </div>
                    <div id="calendar-grid" class="grid grid-cols-7 gap-y-2 text-center text-sm"></div>
                </div>

                <button id="add-selected-btn" class="mt-4 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-300">
                    選択した日付をシフトに追加
                </button>

                <div id="shift-list-container" class="mt-6">
                    <h3 class="text-lg font-bold mb-2">追加済みのシフト</h3>
                    <ul id="shift-list" class="space-y-2 text-sm"></ul>
                </div>
                 <button id="clear-shifts-btn" class="mt-4 w-full bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400 transition-colors duration-300">
                    全シフトを削除
                </button>
            </div>

            <!-- 壁紙プレビュー＆生成エリア -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-2xl font-bold mb-4 border-b pb-2">2. 壁紙をダウンロード</h2>
                
                <div class="canvas-container shadow-inner bg-gray-200">
                    <canvas id="wallpaper-canvas"></canvas>
                </div>

                <div class="mt-6 space-y-3">
                    <a id="download-link" class="hidden w-full bg-blue-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-400 transition-colors duration-300 text-lg text-center">
                        ダウンロード
                    </a>
                </div>
                 <p class="text-xs text-gray-500 mt-4 text-center">
                    シフトを追加・削除するとプレビューが自動更新されます。
                </p>
            </div>
        </main>
        
        <footer class="text-center mt-12 py-4">
            <p class="text-sm text-gray-500">© 2024 シフト壁紙ジェネレーター. All Rights Reserved.</p>
        </footer>
    </div>

    <!-- 確認モーダル -->
    <div id="confirmation-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="modal-message" class="mb-4">すべてのシフトを削除しますか？</p>
            <div class="flex justify-center gap-4">
                <button id="modal-confirm-btn" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">はい</button>
                <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-300 rounded hover:bg-gray-400">いいえ</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- 定数定義 ---
            const CANVAS_WIDTH = 1179;
            const CANVAS_HEIGHT = 2556;
            const WALLPAPER_FONT = '"Emblema One", sans-serif';
            const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const DAY_NAMES_JA = ['日', '月', '火', '水', '木', '金', '土'];
            const DAY_NAMES_EN = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            // --- DOM要素のキャッシュ ---
            const ui = {
                shiftList: document.getElementById('shift-list'),
                clearShiftsBtn: document.getElementById('clear-shifts-btn'),
                downloadLink: document.getElementById('download-link'),
                canvas: document.getElementById('wallpaper-canvas'),
                ctx: document.getElementById('wallpaper-canvas').getContext('2d'),
                monthYearHeader: document.getElementById('month-year-header'),
                prevMonthBtn: document.getElementById('prev-month-btn'),
                nextMonthBtn: document.getElementById('next-month-btn'),
                calendarGrid: document.getElementById('calendar-grid'),
                addSelectedBtn: document.getElementById('add-selected-btn'),
                modal: document.getElementById('confirmation-modal'),
                modalMessage: document.getElementById('modal-message'),
                modalConfirmBtn: document.getElementById('modal-confirm-btn'),
                modalCancelBtn: document.getElementById('modal-cancel-btn'),
            };

            // --- アプリケーションの状態管理 ---
            const state = {
                shifts: [],
                calendarDate: new Date(),
                selectedDates: new Set(),
                modalCallback: null,
            };

            // --- 関数 ---

            /** 壁紙のプレビューを更新し、ダウンロードリンクを表示する */
            const updateWallpaperPreview = () => {
                // ★★★ 修正点: フォントの読み込みを待たずに描画を開始 ★★★
                drawWallpaper();
                ui.downloadLink.href = ui.canvas.toDataURL('image/png');
                ui.downloadLink.download = `shift_wallpaper_${Date.now()}.png`;
                if (state.shifts.length > 0) {
                    ui.downloadLink.classList.remove('hidden');
                } else {
                    ui.downloadLink.classList.add('hidden');
                }
            };
            
            /** 追加済みのシフトリストを画面に描画する */
            const renderShiftList = () => {
                ui.shiftList.innerHTML = '';
                if (state.shifts.length === 0) {
                    ui.shiftList.innerHTML = '<li class="text-gray-500">まだシフトが追加されていません。</li>';
                    return;
                }
                
                state.shifts.sort((a, b) => new Date(a.date) - new Date(b.date));

                state.shifts.forEach((shift, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center bg-gray-100 p-2 rounded-md';
                    const date = new Date(shift.date.replace(/-/g, '/'));
                    const formattedDate = `${date.getMonth() + 1}/${date.getDate()}(${DAY_NAMES_JA[date.getDay()]})`;
                    li.innerHTML = `
                        <span><strong>${formattedDate}:</strong> ${shift.name}</span>
                        <button data-index="${index}" class="remove-btn text-red-500 hover:text-red-700 font-bold" aria-label="${formattedDate}のシフトを削除">×</button>
                    `;
                    ui.shiftList.appendChild(li);
                });
            };

            /** 入力用のカレンダーUIを生成する */
            const generateInputCalendar = (year, month) => {
                ui.calendarGrid.innerHTML = '';
                ui.monthYearHeader.textContent = `${year}年 ${month + 1}月`;
                
                const firstDay = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                DAY_NAMES_JA.forEach(day => {
                    const dayEl = document.createElement('div');
                    dayEl.className = 'font-bold text-xs';
                    dayEl.textContent = day;
                    ui.calendarGrid.appendChild(dayEl);
                });

                for (let i = 0; i < firstDay; i++) {
                    ui.calendarGrid.appendChild(document.createElement('div'));
                }

                for (let i = 1; i <= daysInMonth; i++) {
                    const dayEl = document.createElement('div');
                    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                    dayEl.className = 'calendar-day';
                    dayEl.textContent = i;
                    dayEl.dataset.date = dateStr;

                    if (state.selectedDates.has(dateStr)) {
                        dayEl.classList.add('selected');
                    }
                    ui.calendarGrid.appendChild(dayEl);
                }
            };

            /** 壁紙のCanvasを描画する */
            const drawWallpaper = () => {
                const { ctx } = ui;
                if (!ctx) {
                    console.error("Canvas context is not available.");
                    return;
                }

                const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                gradient.addColorStop(0, '#2c3e50');
                gradient.addColorStop(1, '#3498db');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                let baseDate = state.shifts.length > 0 ? new Date(state.shifts[0].date.replace(/-/g, '/')) : state.calendarDate;

                if (state.shifts.length === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.font = `48px ${WALLPAPER_FONT}`;
                    ctx.textAlign = 'center';
                    ctx.fillText('シフトを追加して壁紙を作成', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                }

                let calendarStartDate, calendarEndDate;
                const baseDay = baseDate.getDate();

                if (baseDay < 15) {
                    calendarStartDate = new Date(baseDate.getFullYear(), baseDate.getMonth() - 1, 15);
                    calendarEndDate = new Date(baseDate.getFullYear(), baseDate.getMonth(), 15);
                } else {
                    calendarStartDate = new Date(baseDate.getFullYear(), baseDate.getMonth(), 15);
                    calendarEndDate = new Date(baseDate.getFullYear(), baseDate.getMonth() + 1, 15);
                }

                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = `72px ${WALLPAPER_FONT}`;
                ctx.textAlign = 'center';
                ctx.fillText(`${MONTH_NAMES[calendarStartDate.getMonth()]} - ${MONTH_NAMES[calendarEndDate.getMonth()]} ${calendarStartDate.getFullYear()}`, CANVAS_WIDTH / 2, 850);

                const horizontalPadding = 80;
                const calendarWidth = CANVAS_WIDTH - (horizontalPadding * 2);
                const calendarTopMargin = 1000;
                const cellWidth = calendarWidth / 7;
                const cellHeight = 150;
                const shiftMap = new Map(state.shifts.map(s => [new Date(s.date.replace(/-/g, '/')).toDateString(), s.name]));

                ctx.font = `40px ${WALLPAPER_FONT}`;
                DAY_NAMES_EN.forEach((day, index) => {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillText(day, horizontalPadding + cellWidth * (index + 0.5), calendarTopMargin);
                });

                let dayIterator = new Date(calendarStartDate);
                dayIterator.setDate(dayIterator.getDate() - dayIterator.getDay());

                for (let weekIndex = 0; weekIndex < 6; weekIndex++) {
                    for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                        const currentGridDate = new Date(dayIterator.getFullYear(), dayIterator.getMonth(), dayIterator.getDate() + (weekIndex * 7) + dayIndex);
                        if (currentGridDate < calendarStartDate || currentGridDate > calendarEndDate) continue;

                        const x = horizontalPadding + cellWidth * (dayIndex + 0.5);
                        const y = (calendarTopMargin + 80) + cellHeight * weekIndex;
                        const dayOfMonth = currentGridDate.getDate();

                        if (shiftMap.has(currentGridDate.toDateString())) {
                            ctx.beginPath();
                            ctx.arc(x, y, 50, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.fill();
                            ctx.fillStyle = '#2c3e50';
                            ctx.font = `48px ${WALLPAPER_FONT}`;
                            ctx.fillText(dayOfMonth, x, y + 15);
                            if (currentGridDate.getDay() === 0) {
                                const shiftTime = shiftMap.get(currentGridDate.toDateString());
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                                ctx.font = `32px ${WALLPAPER_FONT}`;
                                ctx.fillText(shiftTime, x, y + 85);
                            }
                        } else {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.font = `48px ${WALLPAPER_FONT}`;
                            ctx.fillText(dayOfMonth, x, y + 15);
                        }
                    }
                }
            };

            /** 確認モーダルを表示する */
            const showConfirmationModal = (message, callback) => {
                ui.modalMessage.textContent = message;
                state.modalCallback = callback;
                ui.modal.classList.remove('hidden');
            };

            // --- イベントハンドラ ---
            const handleMonthChange = (offset) => {
                state.calendarDate.setMonth(state.calendarDate.getMonth() + offset);
                generateInputCalendar(state.calendarDate.getFullYear(), state.calendarDate.getMonth());
                if (state.shifts.length === 0) {
                    updateWallpaperPreview();
                }
            };

            const handleAddShifts = () => {
                const existingDates = new Set(state.shifts.map(s => s.date));
                state.selectedDates.forEach(dateStr => {
                    if (existingDates.has(dateStr)) return;
                    const date = new Date(dateStr.replace(/-/g, '/'));
                    const name = (date.getDay() === 0) ? '16:30' : '17:00-22:00';
                    state.shifts.push({ date: dateStr, name });
                });
                state.selectedDates.clear();
                renderShiftList();
                generateInputCalendar(state.calendarDate.getFullYear(), state.calendarDate.getMonth());
                updateWallpaperPreview();
            };

            const handleRemoveShift = (e) => {
                const removeBtn = e.target.closest('.remove-btn');
                if (removeBtn) {
                    const index = parseInt(removeBtn.dataset.index, 10);
                    state.shifts.splice(index, 1);
                    renderShiftList();
                    updateWallpaperPreview();
                }
            };
            
            const handleClearAllShifts = () => {
                showConfirmationModal('すべてのシフトを削除しますか？', (confirmed) => {
                    if (confirmed) {
                        state.shifts = [];
                        renderShiftList();
                        updateWallpaperPreview();
                    }
                });
            };

            const handleDateSelect = (e) => {
                const target = e.target.closest('.calendar-day');
                if (target) {
                    const dateStr = target.dataset.date;
                    if (state.selectedDates.has(dateStr)) {
                        state.selectedDates.delete(dateStr);
                        target.classList.remove('selected');
                    } else {
                        state.selectedDates.add(dateStr);
                        target.classList.add('selected');
                    }
                }
            };

            // --- イベントリスナーの設定 ---
            const setupEventListeners = () => {
                ui.prevMonthBtn.addEventListener('click', () => handleMonthChange(-1));
                ui.nextMonthBtn.addEventListener('click', () => handleMonthChange(1));
                ui.addSelectedBtn.addEventListener('click', handleAddShifts);
                ui.shiftList.addEventListener('click', handleRemoveShift);
                ui.clearShiftsBtn.addEventListener('click', handleClearAllShifts);
                ui.calendarGrid.addEventListener('click', handleDateSelect);
                
                ui.modalConfirmBtn.addEventListener('click', () => {
                    if (state.modalCallback) state.modalCallback(true);
                    ui.modal.classList.add('hidden');
                });
                ui.modalCancelBtn.addEventListener('click', () => {
                    if (state.modalCallback) state.modalCallback(false);
                    ui.modal.classList.add('hidden');
                });
            };

            // --- 初期化処理 ---
            const init = () => {
                ui.canvas.width = CANVAS_WIDTH;
                ui.canvas.height = CANVAS_HEIGHT;
                setupEventListeners();
                renderShiftList();
                generateInputCalendar(state.calendarDate.getFullYear(), state.calendarDate.getMonth());
                updateWallpaperPreview();
            };

            init();
        });
    </script>
</body>
</html>
